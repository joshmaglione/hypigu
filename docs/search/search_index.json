{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HypIgu Author: Joshua Maglione . Documentation for the HypIgu package for SageMath . Purpose The goal of HypIgu ( HYP erplane IGU sa) is to provide SageMath with the functionality to compute various zeta functions associated with hyperplane arrangements. Included are common constructions for hyperplane arrangements and specializations of the flag Hilbert\u2013Poincar\u00e9 series defined in Maglione\u2013Voll . Mathematical details are given in Maglione\u2013Voll . We outline the functions included in HypIgu and provide example cases. Setup The simplest way to install HypIgu is to run the following $ sage --pip install hypigu Alternatively, one can download the latest release and unzip it into a directory that SageMath can find for importing. To update an older version of HypIgu to the latest version, run the following $ sage --pip install hypigu --upgrade HypIgu has no external dependencies and is compatible with SageMath 9.6 and later. It may work just fine with earlier versions of SageMath, but these have not been tested. Importing Import HypIgu during your SageMath run with the following import hypigu as hi Throughout this documentation, we use hi for the reference name of hypigu . Funding This work was supported in part by DFG-grant 373111162 . References Joshua Maglione and Christopher Voll . Flag Hilbert\u2013Poincar\u00e9 series of hyperplane arrangements and Igusa zeta functions, to appear in Israel J. Math. 2021. arXiv:2103:03640 .","title":"Home"},{"location":"#hypigu","text":"Author: Joshua Maglione . Documentation for the HypIgu package for SageMath .","title":"HypIgu"},{"location":"#purpose","text":"The goal of HypIgu ( HYP erplane IGU sa) is to provide SageMath with the functionality to compute various zeta functions associated with hyperplane arrangements. Included are common constructions for hyperplane arrangements and specializations of the flag Hilbert\u2013Poincar\u00e9 series defined in Maglione\u2013Voll . Mathematical details are given in Maglione\u2013Voll . We outline the functions included in HypIgu and provide example cases.","title":"Purpose"},{"location":"#setup","text":"The simplest way to install HypIgu is to run the following $ sage --pip install hypigu Alternatively, one can download the latest release and unzip it into a directory that SageMath can find for importing. To update an older version of HypIgu to the latest version, run the following $ sage --pip install hypigu --upgrade HypIgu has no external dependencies and is compatible with SageMath 9.6 and later. It may work just fine with earlier versions of SageMath, but these have not been tested.","title":"Setup"},{"location":"#importing","text":"Import HypIgu during your SageMath run with the following import hypigu as hi Throughout this documentation, we use hi for the reference name of hypigu .","title":"Importing"},{"location":"#funding","text":"This work was supported in part by DFG-grant 373111162 .","title":"Funding"},{"location":"#references","text":"Joshua Maglione and Christopher Voll . Flag Hilbert\u2013Poincar\u00e9 series of hyperplane arrangements and Igusa zeta functions, to appear in Israel J. Math. 2021. arXiv:2103:03640 .","title":"References"},{"location":"constructors/","text":"Constructors We provide a number of constructions of hyperplane arrangements. This uses the default hyperplane arrangement class in SageMath. There is some overlap with the default hyperplane arrangement library , and one is encouraged to search there in case your favorite hyperplane arrangement is not in our list. Most of our constructions are Coxeter-theoretic\u2014meaning, they take as input $\\mathsf{X}$ and $n$, where $\\mathsf{X}$ is the Coxeter type and $n$ is the (Coxeter) rank. For example the Catalan arrangement of type $\\mathsf{X}_n$ can be defined for all Coxeter arrangements like its defined for the (type $\\mathsf{A}$) braid arrangement. CatalanArrangement Input : a string or an iterable container of strings. Output : the associated Catalan arrangement. If just one string is provided, it should be formatted like 'Xn' , where X is a roman letter from $\\mathsf{A}$ to $\\mathsf{H}$ and n is a positive integer. Iterable containers of strings need to have strings formatted in this way. Strings can also be separated by one white space like 'Xm Yn' instead of being in an iterable container. If $\\mathcal{A}$ is a Coxeter arrangement of type $\\mathsf{X}_n$, then the Catalan arrangement of type $\\mathsf{X}_n$ is [ \\mathcal{C} = \\{L - 1 ~|~ L\\in\\mathcal{A} \\} \\cup \\mathcal{A} \\cup \\{L + 1 ~|~ L\\in\\mathcal{A} \\}. ] Example (The Catalan arrangement) The Catalan arrangement is defined as [ \\{X_i - X_j + \\varepsilon ~|~ 1\\leqslant i < j \\leqslant n+1,\\; \\varepsilon\\in\\{-1, 0, 1\\} \\}. ] We can quickly construct this as a type $\\mathsf{A}_n$ Catalan arrangement for $n=2$. sage: A = hi.CatalanArrangement(\"A2\") sage: A Arrangement of 9 hyperplanes of dimension 3 and rank 2 sage: A.hyperplanes() (Hyperplane 0*x0 + x1 - x2 - 1, Hyperplane 0*x0 + x1 - x2 + 0, Hyperplane 0*x0 + x1 - x2 + 1, Hyperplane x0 - x1 + 0*x2 - 1, Hyperplane x0 - x1 + 0*x2 + 0, Hyperplane x0 - x1 + 0*x2 + 1, Hyperplane x0 + 0*x1 - x2 - 1, Hyperplane x0 + 0*x1 - x2 + 0, Hyperplane x0 + 0*x1 - x2 + 1) Example (${\\footnotesize \\mathsf{B}_4}$-Catalan arrangement) The Coxeter arrangement of type $\\mathsf{B}_4$ has $16$ hyperplanes in $\\mathbb{Q}^4$. Thus, the associated Catalan arrangement is non-central with $48$ hyperplanes in $\\mathbb{Q}^4$. We verify this. sage: A = hi.CatalanArrangement(\"B4\") sage: A Arrangement of 48 hyperplanes of dimension 4 and rank 4 sage: A.is_central() False CoxeterArrangement Input : a string or an iterable container of strings. Output : the associated Coxeter arrangement. If just one string is provided, it should be formatted like 'Xn' , where X is a roman letter from $\\mathsf{A}$ to $\\mathsf{H}$ and n is a positive integer. Iterable containers of strings need to have strings formatted in this way. Strings can also be separated by one white space like 'Xm Yn' instead of being in an iterable container. Example (Braid arrangement) The braid arrangement with $n+1$ hyperplanes is equivalent to the type $\\mathsf{A}_n$ Coxeter arrangement: [ \\{X_i - X_j ~|~ 1\\leqslant i < j \\leqslant n+1\\}. ] We construct the braid arrangement with $3$ hyperplanes. sage: hi.CoxeterArrangement(\"A2\") Arrangement <x1 - x2 | x0 - x1 | x0 - x2> Example (Boolean arrangement) One should consider the other two constructions of the Boolean arrangement via direct sums and polynomials . The Boolean arrangement with $n$ hyperplanes is a Coxeter arrangement, equivalent to $\\mathsf{A}_1^n$, the direct sum of $n$ copies of $\\mathsf{A}_1$. We construct the rank $5$ Boolean arrangement in two different ways. Note that, when created this way, the ambient dimension is double the rank. sage: bool5 = \"A1 A1 A1 A1 A1\" sage: hi.CoxeterArrangement(bool5) Arrangement of 5 hyperplanes of dimension 10 and rank 5 Another construction is as follows. sage: L = [\"A1\" for i in range(5)] sage: L ['A1', 'A1', 'A1', 'A1', 'A1'] sage: hi.CoxeterArrangement(L) Arrangement of 5 hyperplanes of dimension 10 and rank 5 Example (Coxeter type ${\\footnotesize \\mathsf{I}_2(m)}$) In all other Coxeter types, the integer corresponds to the rank. The exception is with type $\\mathsf{I}$. If the input is type $\\mathsf{I}$, then the integer corresponds to the number of hyperplanes. Here, we give a $\\mathbb{Q}$-representation of $\\mathsf{I}_2(8)$ as follows. sage: A = hi.CoxeterArrangement(\"I8\") sage: A Arrangement of 8 hyperplanes of dimension 2 and rank 2 sage: A.hyperplanes() (Hyperplane -x0 + 2*x1 + 0, Hyperplane -x0 + 3*x1 + 0, Hyperplane 0*x0 + x1 + 0, Hyperplane x0 - x1 + 0, Hyperplane x0 + 0*x1 + 0, Hyperplane x0 + x1 + 0, Hyperplane x0 + 2*x1 + 0, Hyperplane x0 + 3*x1 + 0) DirectSum Input : an iterable container of hyperplane arrangements. Output : the direct sum arrangement. The direct sum arrangement is also known as the product arrangement. Example (Boolean arrangement again) One should compare this example with the other Boolean examples: as a Coxeter arrangement and as an arrangement from a polynomial . First we create the irreducible factor: the origin on the rational line. sage: H = HyperplaneArrangements(QQ, 'x') sage: A = H([0, 1]) sage: A Arrangement <x> Now we create higher rank Boolean arrangements in two slightly different ways. The rank $4$ Boolean arrangement is given as follows. sage: hi.DirectSum(A, A, A, A) Arrangement <x3 | x2 | x1 | x0> And the rank $256$ Boolean arrangement is sage: L = [A for i in range(256)] sage: hi.DirectSum(L) Arrangement of 256 hyperplanes of dimension 256 and rank 256 LinialArrangement Input : a string or an iterable container of strings. Output : the associated Linial arrangement. If just one string is provided, it should be formatted like 'Xn' , where X is a roman letter from $\\mathsf{A}$ to $\\mathsf{H}$ and n is a positive integer. Iterable containers of strings need to have strings formatted in this way. Strings can also be separated by one white space like 'Xm Yn' instead of being in an iterable container. If $\\mathcal{A}$ is a Coxeter arrangement of type $\\mathsf{X}_n$, then the Linial arrangement of type $\\mathsf{X}_n$ is [ \\mathcal{L} = \\{L - 1 ~|~ L\\in\\mathcal{A} \\} . ] Example (The Linial arrangement) Usually the Linial arrangement is defined without reference to a Coxeter type and is given as the type-$\\mathsf{A}$ version above. We construct the Linial arrangement of type $\\mathsf{A}_2$. sage: A = hi.LinialArrangement(\"A2\") sage: A Arrangement <x1 - x2 + 1 | x0 - x1 + 1 | x0 - x2 + 1> PolynomialToArrangement Input : a polynomial or symbolic expression. Output : the hyperplane arrangement associated with the linear factors of the given polynomial. We require that the given polynomial only have linear factors. Strings are also acceptable input and will be interpreted by SageMath (so they should be formatted accordingly). The underlying field for such symbolic expressions is assumed to be $\\mathbb{Q}$. Example (Boolean arrangement yet again) Compare this construction with the Boolean construction as a Coxeter arrangement and as a direct sum . The Boolean arrangement is equivalent to the arrangement of coordinate hyperplanes, so the corresponding polynomial is a monomial. We construct the rank $5$ Boolean arrangement. sage: a, b, c, d, e = var('a b c d e') sage: f = a*b*c*d*e sage: A = hi.PolynomialToArrangement(f) sage: A Arrangement of 5 hyperplanes of dimension 5 and rank 5 Equivalently, one can input just the string. sage: B = hi.PolynomialToArrangement('a*b*c*d*e') sage: A == B True Example (Cyclotomic) Let $\\zeta_5$ be a primitive $5$th root of unity. We construct the arrangement of $5$ lines through the origin with underlying field $\\mathbb{Q}(\\zeta_5)$. This can be accomplished by constructing the hyperplane arrangement associated to the polynomial $X^5 - Y^5\\in \\mathbb{Q}(\\zeta_5)[X, Y]$. Note that this arrangement is equivalent to the Coxeter arrangement of type $\\mathsf{I}_2(5)\\cong \\mathsf{H}_2$; see the $\\mathsf{I}_2(m)$ Example . sage: K = CyclotomicField(5) sage: R.<X, Y> = PolynomialRing(K) sage: f = X**5 - Y**5 sage: A = hi.PolynomialToArrangement(f) sage: A Arrangement of 5 hyperplanes of dimension 2 and rank 2 sage: A.hyperplanes() (Hyperplane X + (-zeta5^2)*Y + 0, Hyperplane X + (zeta5^3 + zeta5^2 + zeta5 + 1)*Y + 0, Hyperplane X + (-zeta5^3)*Y + 0, Hyperplane X + (-zeta5)*Y + 0, Hyperplane X + (-1)*Y + 0) Note that if the underlying field were just, say, $\\mathbb{Q}$, then this would result in an error since $f$ is not a product of linear factors. ResonanceArrangement Input : a positive integer. Output : the resonance arrangement. The resonance arrangement, $\\mathcal{R}_n$, of rank $n$ is [ \\left\\{ \\sum_{i\\in I}X_i ~\\middle|~ \\varnothing \\neq I\\subseteq \\{1,\\dots, n\\} \\right\\} . ] Example (The resonance arrangement) We construct the resonance arrangement of rank $4$, which should contain $2^4-1$ hyperplanes. sage: A = hi.ResonanceArrangement(4) sage: A Arrangement of 15 hyperplanes of dimension 4 and rank 4 ShiArrangement Input : a string or an iterable container of strings. Output : the associated Shi arrangement. If just one string is provided, it should be formatted like 'Xn' , where X is a roman letter from $\\mathsf{A}$ to $\\mathsf{H}$ and n is a positive integer. Iterable containers of strings need to have strings formatted in this way. Strings can also be separated by one white space like 'Xm Yn' instead of being in an iterable container. If $\\mathcal{A}$ is a Coxeter arrangement of type $\\mathsf{X}_n$, then the Shi arrangement of type $\\mathsf{X}_n$ is [ \\mathcal{S} = \\mathcal{A} \\cup \\{L - 1 ~|~ L\\in\\mathcal{A} \\} . ] Example (The Shi arrangement) Like with some of our other constructors, the usual definition makes no reference to Coxeter types, so the Shi arrangement is equal to the type-$\\mathsf{A}$ Shi arrangement defined above. We can easily construct this for $\\mathsf{A}_2$. sage: A = hi.ShiArrangement(\"A2\") sage: A Arrangement of 6 hyperplanes of dimension 3 and rank 2","title":"Constructors"},{"location":"constructors/#constructors","text":"We provide a number of constructions of hyperplane arrangements. This uses the default hyperplane arrangement class in SageMath. There is some overlap with the default hyperplane arrangement library , and one is encouraged to search there in case your favorite hyperplane arrangement is not in our list. Most of our constructions are Coxeter-theoretic\u2014meaning, they take as input $\\mathsf{X}$ and $n$, where $\\mathsf{X}$ is the Coxeter type and $n$ is the (Coxeter) rank. For example the Catalan arrangement of type $\\mathsf{X}_n$ can be defined for all Coxeter arrangements like its defined for the (type $\\mathsf{A}$) braid arrangement.","title":"Constructors"},{"location":"constructors/#catalanarrangement","text":"Input : a string or an iterable container of strings. Output : the associated Catalan arrangement. If just one string is provided, it should be formatted like 'Xn' , where X is a roman letter from $\\mathsf{A}$ to $\\mathsf{H}$ and n is a positive integer. Iterable containers of strings need to have strings formatted in this way. Strings can also be separated by one white space like 'Xm Yn' instead of being in an iterable container. If $\\mathcal{A}$ is a Coxeter arrangement of type $\\mathsf{X}_n$, then the Catalan arrangement of type $\\mathsf{X}_n$ is [ \\mathcal{C} = \\{L - 1 ~|~ L\\in\\mathcal{A} \\} \\cup \\mathcal{A} \\cup \\{L + 1 ~|~ L\\in\\mathcal{A} \\}. ]","title":"CatalanArrangement"},{"location":"constructors/#example-the-catalan-arrangement","text":"The Catalan arrangement is defined as [ \\{X_i - X_j + \\varepsilon ~|~ 1\\leqslant i < j \\leqslant n+1,\\; \\varepsilon\\in\\{-1, 0, 1\\} \\}. ] We can quickly construct this as a type $\\mathsf{A}_n$ Catalan arrangement for $n=2$. sage: A = hi.CatalanArrangement(\"A2\") sage: A Arrangement of 9 hyperplanes of dimension 3 and rank 2 sage: A.hyperplanes() (Hyperplane 0*x0 + x1 - x2 - 1, Hyperplane 0*x0 + x1 - x2 + 0, Hyperplane 0*x0 + x1 - x2 + 1, Hyperplane x0 - x1 + 0*x2 - 1, Hyperplane x0 - x1 + 0*x2 + 0, Hyperplane x0 - x1 + 0*x2 + 1, Hyperplane x0 + 0*x1 - x2 - 1, Hyperplane x0 + 0*x1 - x2 + 0, Hyperplane x0 + 0*x1 - x2 + 1)","title":"Example (The Catalan arrangement)"},{"location":"constructors/#example-footnotesize-mathsfb_4-catalan-arrangement","text":"The Coxeter arrangement of type $\\mathsf{B}_4$ has $16$ hyperplanes in $\\mathbb{Q}^4$. Thus, the associated Catalan arrangement is non-central with $48$ hyperplanes in $\\mathbb{Q}^4$. We verify this. sage: A = hi.CatalanArrangement(\"B4\") sage: A Arrangement of 48 hyperplanes of dimension 4 and rank 4 sage: A.is_central() False","title":"Example (${\\footnotesize \\mathsf{B}_4}$-Catalan arrangement)"},{"location":"constructors/#coxeterarrangement","text":"Input : a string or an iterable container of strings. Output : the associated Coxeter arrangement. If just one string is provided, it should be formatted like 'Xn' , where X is a roman letter from $\\mathsf{A}$ to $\\mathsf{H}$ and n is a positive integer. Iterable containers of strings need to have strings formatted in this way. Strings can also be separated by one white space like 'Xm Yn' instead of being in an iterable container.","title":"CoxeterArrangement"},{"location":"constructors/#example-braid-arrangement","text":"The braid arrangement with $n+1$ hyperplanes is equivalent to the type $\\mathsf{A}_n$ Coxeter arrangement: [ \\{X_i - X_j ~|~ 1\\leqslant i < j \\leqslant n+1\\}. ] We construct the braid arrangement with $3$ hyperplanes. sage: hi.CoxeterArrangement(\"A2\") Arrangement <x1 - x2 | x0 - x1 | x0 - x2>","title":"Example (Braid arrangement)"},{"location":"constructors/#example-boolean-arrangement","text":"One should consider the other two constructions of the Boolean arrangement via direct sums and polynomials . The Boolean arrangement with $n$ hyperplanes is a Coxeter arrangement, equivalent to $\\mathsf{A}_1^n$, the direct sum of $n$ copies of $\\mathsf{A}_1$. We construct the rank $5$ Boolean arrangement in two different ways. Note that, when created this way, the ambient dimension is double the rank. sage: bool5 = \"A1 A1 A1 A1 A1\" sage: hi.CoxeterArrangement(bool5) Arrangement of 5 hyperplanes of dimension 10 and rank 5 Another construction is as follows. sage: L = [\"A1\" for i in range(5)] sage: L ['A1', 'A1', 'A1', 'A1', 'A1'] sage: hi.CoxeterArrangement(L) Arrangement of 5 hyperplanes of dimension 10 and rank 5","title":"Example (Boolean arrangement)"},{"location":"constructors/#example-coxeter-type-footnotesize-mathsfi_2m","text":"In all other Coxeter types, the integer corresponds to the rank. The exception is with type $\\mathsf{I}$. If the input is type $\\mathsf{I}$, then the integer corresponds to the number of hyperplanes. Here, we give a $\\mathbb{Q}$-representation of $\\mathsf{I}_2(8)$ as follows. sage: A = hi.CoxeterArrangement(\"I8\") sage: A Arrangement of 8 hyperplanes of dimension 2 and rank 2 sage: A.hyperplanes() (Hyperplane -x0 + 2*x1 + 0, Hyperplane -x0 + 3*x1 + 0, Hyperplane 0*x0 + x1 + 0, Hyperplane x0 - x1 + 0, Hyperplane x0 + 0*x1 + 0, Hyperplane x0 + x1 + 0, Hyperplane x0 + 2*x1 + 0, Hyperplane x0 + 3*x1 + 0)","title":"Example (Coxeter type ${\\footnotesize \\mathsf{I}_2(m)}$)"},{"location":"constructors/#directsum","text":"Input : an iterable container of hyperplane arrangements. Output : the direct sum arrangement. The direct sum arrangement is also known as the product arrangement.","title":"DirectSum"},{"location":"constructors/#example-boolean-arrangement-again","text":"One should compare this example with the other Boolean examples: as a Coxeter arrangement and as an arrangement from a polynomial . First we create the irreducible factor: the origin on the rational line. sage: H = HyperplaneArrangements(QQ, 'x') sage: A = H([0, 1]) sage: A Arrangement <x> Now we create higher rank Boolean arrangements in two slightly different ways. The rank $4$ Boolean arrangement is given as follows. sage: hi.DirectSum(A, A, A, A) Arrangement <x3 | x2 | x1 | x0> And the rank $256$ Boolean arrangement is sage: L = [A for i in range(256)] sage: hi.DirectSum(L) Arrangement of 256 hyperplanes of dimension 256 and rank 256","title":"Example (Boolean arrangement again)"},{"location":"constructors/#linialarrangement","text":"Input : a string or an iterable container of strings. Output : the associated Linial arrangement. If just one string is provided, it should be formatted like 'Xn' , where X is a roman letter from $\\mathsf{A}$ to $\\mathsf{H}$ and n is a positive integer. Iterable containers of strings need to have strings formatted in this way. Strings can also be separated by one white space like 'Xm Yn' instead of being in an iterable container. If $\\mathcal{A}$ is a Coxeter arrangement of type $\\mathsf{X}_n$, then the Linial arrangement of type $\\mathsf{X}_n$ is [ \\mathcal{L} = \\{L - 1 ~|~ L\\in\\mathcal{A} \\} . ]","title":"LinialArrangement"},{"location":"constructors/#example-the-linial-arrangement","text":"Usually the Linial arrangement is defined without reference to a Coxeter type and is given as the type-$\\mathsf{A}$ version above. We construct the Linial arrangement of type $\\mathsf{A}_2$. sage: A = hi.LinialArrangement(\"A2\") sage: A Arrangement <x1 - x2 + 1 | x0 - x1 + 1 | x0 - x2 + 1>","title":"Example (The Linial arrangement)"},{"location":"constructors/#polynomialtoarrangement","text":"Input : a polynomial or symbolic expression. Output : the hyperplane arrangement associated with the linear factors of the given polynomial. We require that the given polynomial only have linear factors. Strings are also acceptable input and will be interpreted by SageMath (so they should be formatted accordingly). The underlying field for such symbolic expressions is assumed to be $\\mathbb{Q}$.","title":"PolynomialToArrangement"},{"location":"constructors/#example-boolean-arrangement-yet-again","text":"Compare this construction with the Boolean construction as a Coxeter arrangement and as a direct sum . The Boolean arrangement is equivalent to the arrangement of coordinate hyperplanes, so the corresponding polynomial is a monomial. We construct the rank $5$ Boolean arrangement. sage: a, b, c, d, e = var('a b c d e') sage: f = a*b*c*d*e sage: A = hi.PolynomialToArrangement(f) sage: A Arrangement of 5 hyperplanes of dimension 5 and rank 5 Equivalently, one can input just the string. sage: B = hi.PolynomialToArrangement('a*b*c*d*e') sage: A == B True","title":"Example (Boolean arrangement yet again)"},{"location":"constructors/#example-cyclotomic","text":"Let $\\zeta_5$ be a primitive $5$th root of unity. We construct the arrangement of $5$ lines through the origin with underlying field $\\mathbb{Q}(\\zeta_5)$. This can be accomplished by constructing the hyperplane arrangement associated to the polynomial $X^5 - Y^5\\in \\mathbb{Q}(\\zeta_5)[X, Y]$. Note that this arrangement is equivalent to the Coxeter arrangement of type $\\mathsf{I}_2(5)\\cong \\mathsf{H}_2$; see the $\\mathsf{I}_2(m)$ Example . sage: K = CyclotomicField(5) sage: R.<X, Y> = PolynomialRing(K) sage: f = X**5 - Y**5 sage: A = hi.PolynomialToArrangement(f) sage: A Arrangement of 5 hyperplanes of dimension 2 and rank 2 sage: A.hyperplanes() (Hyperplane X + (-zeta5^2)*Y + 0, Hyperplane X + (zeta5^3 + zeta5^2 + zeta5 + 1)*Y + 0, Hyperplane X + (-zeta5^3)*Y + 0, Hyperplane X + (-zeta5)*Y + 0, Hyperplane X + (-1)*Y + 0) Note that if the underlying field were just, say, $\\mathbb{Q}$, then this would result in an error since $f$ is not a product of linear factors.","title":"Example (Cyclotomic)"},{"location":"constructors/#resonancearrangement","text":"Input : a positive integer. Output : the resonance arrangement. The resonance arrangement, $\\mathcal{R}_n$, of rank $n$ is [ \\left\\{ \\sum_{i\\in I}X_i ~\\middle|~ \\varnothing \\neq I\\subseteq \\{1,\\dots, n\\} \\right\\} . ]","title":"ResonanceArrangement"},{"location":"constructors/#example-the-resonance-arrangement","text":"We construct the resonance arrangement of rank $4$, which should contain $2^4-1$ hyperplanes. sage: A = hi.ResonanceArrangement(4) sage: A Arrangement of 15 hyperplanes of dimension 4 and rank 4","title":"Example (The resonance arrangement)"},{"location":"constructors/#shiarrangement","text":"Input : a string or an iterable container of strings. Output : the associated Shi arrangement. If just one string is provided, it should be formatted like 'Xn' , where X is a roman letter from $\\mathsf{A}$ to $\\mathsf{H}$ and n is a positive integer. Iterable containers of strings need to have strings formatted in this way. Strings can also be separated by one white space like 'Xm Yn' instead of being in an iterable container. If $\\mathcal{A}$ is a Coxeter arrangement of type $\\mathsf{X}_n$, then the Shi arrangement of type $\\mathsf{X}_n$ is [ \\mathcal{S} = \\mathcal{A} \\cup \\{L - 1 ~|~ L\\in\\mathcal{A} \\} . ]","title":"ShiArrangement"},{"location":"constructors/#example-the-shi-arrangement","text":"Like with some of our other constructors, the usual definition makes no reference to Coxeter types, so the Shi arrangement is equal to the type-$\\mathsf{A}$ Shi arrangement defined above. We can easily construct this for $\\mathsf{A}_2$. sage: A = hi.ShiArrangement(\"A2\") sage: A Arrangement of 6 hyperplanes of dimension 3 and rank 2","title":"Example (The Shi arrangement)"},{"location":"graded_posets/","text":"Graded Posets We include a class called GradedPoset . This class keeps track of basic information we need to compute the various generating functions associated with a hyperplane arrangement. GradedPoset Input : arrangement : a hyperplane arrangement. Default None . matroid : a matroid. Default None . poset : a graded poset with a bottom element. Default None . R_label : a function from the covering relations (pairs of poset ) to the integers. Default None . Output : the corresponding graded poset. If an arrangement is given, the poset comes from the intersection poset. If a matroid is given, the poset comes from the lattice of flats. $R$-labels are not checked, so we assume whatever is given is correct. Attributes The class GradedPoset has four attributes, which are the same as the keyword input. Example (Lattice of braid arrangement) We construct the lattice of flats for the braid arrangement in $\\mathbb{R}^4$. sage: A = hi.CoxeterArrangement(\"A3\") sage: A Arrangement of 6 hyperplanes of dimension 4 and rank 3 sage: GP = hi.GradedPoset(arrangement=A) sage: GP An R-labeled graded poset with 15 elements built from the intersection poset of Arrangement of 6 hyperplanes of dimension 4 and rank 3 Now we look at the data stored in the attributes. We display the hyperplanes in the arrangement. sage: GP.arrangement.hyperplanes() (Hyperplane 0*x0 + 0*x1 + x2 - x3 + 0, Hyperplane 0*x0 + x1 - x2 + 0*x3 + 0, Hyperplane 0*x0 + x1 + 0*x2 - x3 + 0, Hyperplane x0 - x1 + 0*x2 + 0*x3 + 0, Hyperplane x0 + 0*x1 - x2 + 0*x3 + 0, Hyperplane x0 + 0*x1 + 0*x2 - x3 + 0) We display the poset as an image. sage: GP.poset Finite lattice containing 15 elements We see that hyperplanes 0, 4, and 5 intersect in a codimension $2$ subspace. sage: [GP.arrangement.hyperplanes()[i] for i in [0,4,5]] [Hyperplane 0*x0 + 0*x1 + x2 - x3 + 0, Hyperplane x0 + 0*x1 - x2 + 0*x3 + 0, Hyperplane x0 + 0*x1 + 0*x2 - x3 + 0] .atoms Output : the atoms of the underlying poset. .interval Input : bottom : the bottom element of the desired interval. Default None . top : the top element of the desired interval. Default None . Output : the closed interval from bottom (if None the unique bottom element is used) to top (if None all suitable maximal elements are used). .Poincare_polynomial Output : the Poincar\u00e9 polynomial of the graded poset. This is defined to be [ \\pi_P(Y) = \\sum_{x\\in P} |\\mu(\\hat{0}, x)|\\cdot Y^{\\mathrm{rank}(x)}. ] .show No output given. This displays the underlying intersection poset.","title":"Graded Posets"},{"location":"graded_posets/#graded-posets","text":"We include a class called GradedPoset . This class keeps track of basic information we need to compute the various generating functions associated with a hyperplane arrangement.","title":"Graded Posets"},{"location":"graded_posets/#gradedposet","text":"Input : arrangement : a hyperplane arrangement. Default None . matroid : a matroid. Default None . poset : a graded poset with a bottom element. Default None . R_label : a function from the covering relations (pairs of poset ) to the integers. Default None . Output : the corresponding graded poset. If an arrangement is given, the poset comes from the intersection poset. If a matroid is given, the poset comes from the lattice of flats. $R$-labels are not checked, so we assume whatever is given is correct.","title":"GradedPoset"},{"location":"graded_posets/#attributes","text":"The class GradedPoset has four attributes, which are the same as the keyword input.","title":"Attributes"},{"location":"graded_posets/#example-lattice-of-braid-arrangement","text":"We construct the lattice of flats for the braid arrangement in $\\mathbb{R}^4$. sage: A = hi.CoxeterArrangement(\"A3\") sage: A Arrangement of 6 hyperplanes of dimension 4 and rank 3 sage: GP = hi.GradedPoset(arrangement=A) sage: GP An R-labeled graded poset with 15 elements built from the intersection poset of Arrangement of 6 hyperplanes of dimension 4 and rank 3 Now we look at the data stored in the attributes. We display the hyperplanes in the arrangement. sage: GP.arrangement.hyperplanes() (Hyperplane 0*x0 + 0*x1 + x2 - x3 + 0, Hyperplane 0*x0 + x1 - x2 + 0*x3 + 0, Hyperplane 0*x0 + x1 + 0*x2 - x3 + 0, Hyperplane x0 - x1 + 0*x2 + 0*x3 + 0, Hyperplane x0 + 0*x1 - x2 + 0*x3 + 0, Hyperplane x0 + 0*x1 + 0*x2 - x3 + 0) We display the poset as an image. sage: GP.poset Finite lattice containing 15 elements We see that hyperplanes 0, 4, and 5 intersect in a codimension $2$ subspace. sage: [GP.arrangement.hyperplanes()[i] for i in [0,4,5]] [Hyperplane 0*x0 + 0*x1 + x2 - x3 + 0, Hyperplane x0 + 0*x1 - x2 + 0*x3 + 0, Hyperplane x0 + 0*x1 + 0*x2 - x3 + 0]","title":"Example (Lattice of braid arrangement)"},{"location":"graded_posets/#atoms","text":"Output : the atoms of the underlying poset.","title":".atoms"},{"location":"graded_posets/#interval","text":"Input : bottom : the bottom element of the desired interval. Default None . top : the top element of the desired interval. Default None . Output : the closed interval from bottom (if None the unique bottom element is used) to top (if None all suitable maximal elements are used).","title":".interval"},{"location":"graded_posets/#poincare_polynomial","text":"Output : the Poincar\u00e9 polynomial of the graded poset. This is defined to be [ \\pi_P(Y) = \\sum_{x\\in P} |\\mu(\\hat{0}, x)|\\cdot Y^{\\mathrm{rank}(x)}. ]","title":".Poincare_polynomial"},{"location":"graded_posets/#show","text":"No output given. This displays the underlying intersection poset.","title":".show"},{"location":"rational_functions/","text":"Rational Functions The main purpose of this package is to explicitly compute the flag Hilbert\u2013Poincar\u00e9 series and its specializations like Igusa'a local zeta function. We defer to Maglione\u2013Voll for the details on the rational functions. BraidArrangementIgusa Input : a positive integer. Output : the Igusa zeta function associated with the braid arrangement. This is a specialized algorithm for the braid arrangement and is significantly faster than IgusaZetaFunction on the braid arrangement. This is based off of Lemma 5.14 of Maglione\u2013Voll. Example (Time comparison) We compute the Igusa zeta function associated with $\\mathsf{A}_6$ and record the time (on the same machine). sage: %timeit _ = hi.BraidArrangementIgusa(6) 5.55 ms \u00b1 7.58 \u03bcs per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) sage: %timeit _ = hi.IgusaZetaFunction(hi.CoxeterArrangement(\"A6\")) 4.76 s \u00b1 28 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) Thus for $\\mathsf{A}_6$ BraidArrangementIgusa is about 1000 times faster than IgusaZetaFunction \u2014of course the latter is also general purpose. Example (Large example) We compute a factorization of the denominator of the Igusa zeta function associated with $\\mathsf{A}_{10}$. sage: hi.BraidArrangementIgusa(10).denominator().factor() (y*t - 1)^5 * (y*t^2 - 1)^2 * (y*t^3 - 1) * (y*t^4 - 1) * (y^2*t^3 - 1)^3 * (y*t^5 - 1) * (y^2*t^4 + y*t^2 + 1)^2 * (y^2*t^5 - 1)^2 * (y^2*t^5 + 1)^2 * (y^2*t^7 - 1) * (y^2*t^9 - 1) * (y^2*t^9 + 1) * (y^2*t^10 + y*t^5 + 1) * (y^2*t^11 - 1) * (y^4*t^12 + y^3*t^9 + y^2*t^6 + y*t^3 + 1) * (y^4*t^14 + y^2*t^7 + 1) * (y^4*t^18 + 1) * (y^6*t^24 + y^5*t^20 + y^4*t^16 + y^3*t^12 + y^2*t^8 + y*t^4 + 1) * (y^6*t^30 + y^3*t^15 + 1) * (y^8*t^44 + y^6*t^33 + y^4*t^22 + y^2*t^11 + 1) Using a program to rewrite the finite geometric progressions in the denominator (like BRational ), the denominator takes the following form: (1 - y*t)^5*(1 - y^2*t^3)^3*(1 - y^3*t^6)^2*(1 - y^4*t^10)^2*(1 - y^5*t^15)*(1 - y^6*t^21)*(1 - y^7*t^28)*(1 - y^8*t^36)*(1 - y^9*t^45)*(1 - y^10*t^55) CoarseFHPSeries Input : arrangement : a hyperplane arrangement. Default None . matroid : a matroid. Default None . poset : a poset. Default None . R_label : a function from pairs of elements of a poset into the integers. Default None . numerator : return only the numerator. Default False . verbose : turn on print statements. Default False . method : a string stating which method to use. Default recursion . Output : the coarse flag Hilbert\u2013Poincar\u00e9 series associated to the graded poset determined by the input. If R_label is given, it is not verified to be an $R$-label. To use the $R$-label, set method='R-label' . This will use the formula developed in Dorpalen-Barry et al. from Corollary 2.22. In testing, this method seems to be about two times slower than the default recursion. The coarse flag Hilbert\u2013Poincar\u00e9 series associated with a graded poset $P$ is defined to be: [ \\mathsf{cfHP}_{P} (Y, T) = \\sum_{F\\in\\Delta(P \\setminus \\{\\hat{0}\\})} \\pi_F(Y) \\left(\\dfrac{T}{1 - T}\\right)^{|F|} = \\dfrac{\\mathcal{N}_{P}(Y, T)}{(1 - T)^{\\mathrm{rk}(P)}}. ] Example (Boolean arrangement) We verify that the Boolean arrangement, $\\mathcal{A}$, of rank $n$ satisfies the equation [ \\mathsf{cfHP}_{\\mathcal{A}}(Y, T) = \\dfrac{(1+ Y)^n E_n(T)}{(1 - T)^n}, ] where $E_n(T)$ is the $n$th Eulerian polynomial. We set $n=6$ for this example. sage: A = hi.CoxeterArrangement([\"A1\"]*6) sage: A Arrangement of 6 hyperplanes of dimension 12 and rank 6 sage: cfHP = hi.CoarseFHPSeries(A) sage: cfHP.factor() (T - 1)^-6 * (T + 1) * (Y + 1)^6 * (T^4 + 56*T^3 + 246*T^2 + 56*T + 1) Example (Coxeter at ${\\footnotesize Y=1}$) We verify Theorem D of Maglione\u2013Voll for the Coxeter arrangement of type $\\mathsf{D}_5$. Thus, we will show that [ \\mathsf{cfHP}_{\\mathsf{D}_5} (1, T) = 1920\\cdot \\dfrac{1 + 26T + 66T^2 + 26T^3 + T^4}{(1 - T)^5}, ] sage: A = hi.CoxeterArrangement(\"D5\") sage: A Arrangement of 20 hyperplanes of dimension 5 and rank 5 sage: cfHP = hi.CoarseFHPSeries(A) sage: cfHP.factor() (-1) * (T - 1)^-5 * (Y + 1) * (Y^4*T^4 + 397*Y^4*T^3 + 19*Y^3*T^4 + 3143*Y^4*T^2 + 3074*Y^3*T^3 + 131*Y^2*T^4 + 3239*Y^4*T + 15624*Y^3*T^2 + 8556*Y^2*T^3 + 389*Y*T^4 + 420*Y^4 + 9694*Y^3*T + 25826*Y^2*T^2 + 9694*Y*T^3 + 420*T^4 + 389*Y^3 + 8556*Y^2*T + 15624*Y*T^2 + 3239*T^3 + 131*Y^2 + 3074*Y*T + 3143*T^2 + 19*Y + 397*T + 1) So we get exactly what we expect: sage: (cfHP(Y=1)).factor() (-1920) * (T - 1)^-5 * (T^4 + 26*T^3 + 66*T^2 + 26*T + 1) Example (The path poset) We define the path poset $P_4 = \\{1,\\dots, 4\\}$ with the usual order $<$ of natural numbers. This is a graded poset with an $R$-label. We then compute the corresponding coarse flag Hilbert\u2013Poincar\u00e9 series. We note that there is no matroid whose lattice of flats is isomorphic to $P_n$. sage: P = Poset(DiGraph([(i, i+1) for i in range(1, 5)])) sage: hi.CoarseFHPSeries(poset=P).factor() (T - 1)^-4 * (Y + 1) * (Y*T + 1)^3 FlagHilbertPoincareSeries Input : arrangement : a hyperplane arrangement. Default None . matroid : a matroid. Default None . poset : a poset. Default None . verbose : turn on print statements. Default False . Output : the flag Hilbert\u2013Poincar\u00e9 series associated to the graded poset determined by the input data. The flag Hilbert\u2013Poincar\u00e9 series of a graded poset $P$ is defined to be: [ \\mathsf{fHP}_{P} (Y, \\bm{T}) = \\sum_{F\\in\\Delta(P \\setminus \\{\\hat{0}\\})} \\pi_F(Y) \\prod_{x\\in F} \\frac{T_x}{1 - T_x}. ] Example (Lines through the origin again) Because of the massive amount of variables in this function, we keep the number of hyperplanes small in this example. We compute the flag Hilbert\u2013Poincar\u00e9 series of the arrangement given by 5 lines passes through the origin in a $2$-dimensional vector space. sage: K = CyclotomicField(5) sage: R.<X, Y> = PolynomialRing(K) sage: f = X**5 - Y**5 sage: A = hi.PolynomialToArrangement(f) sage: A Arrangement of 5 hyperplanes of dimension 2 and rank 2 sage: hi.FlagHilbertPoincareSeries(A).factor() (T6 - 1)^-1 * (T5 - 1)^-1 * (T4 - 1)^-1 * (T3 - 1)^-1 * (T2 - 1)^-1 * (T1 - 1)^-1 * (Y + 1) * (Y*T1*T2*T3*T4*T5 + 4*T1*T2*T3*T4*T5 - Y*T1*T2*T3 - Y*T1*T2*T4 - Y*T1*T3*T4 - Y*T2*T3*T4 - 3*T1*T2*T3*T4 - Y*T1*T2*T5 - Y*T1*T3*T5 - Y*T2*T3*T5 - 3*T1*T2*T3*T5 - Y*T1*T4*T5 - Y*T2*T4*T5 - 3*T1*T2*T4*T5 - Y*T3*T4*T5 - 3*T1*T3*T4*T5 - 3*T2*T3*T4*T5 + 2*Y*T1*T2 + 2*Y*T1*T3 + 2*Y*T2*T3 + 2*T1*T2*T3 + 2*Y*T1*T4 + 2*Y*T2*T4 + 2*T1*T2*T4 + 2*Y*T3*T4 + 2*T1*T3*T4 + 2*T2*T3*T4 + 2*Y*T1*T5 + 2*Y*T2*T5 + 2*T1*T2*T5 + 2*Y*T3*T5 + 2*T1*T3*T5 + 2*T2*T3*T5 + 2*Y*T4*T5 + 2*T1*T4*T5 + 2*T2*T4*T5 + 2*T3*T4*T5 - 3*Y*T1 - 3*Y*T2 - T1*T2 - 3*Y*T3 - T1*T3 - T2*T3 - 3*Y*T4 - T1*T4 - T2*T4 - T3*T4 - 3*Y*T5 - T1*T5 - T2*T5 - T3*T5 - T4*T5 + 4*Y + 1) This is, indeed, equal to [ \\dfrac{1 + Y}{1 - T_6}\\left(1 + 4Y + (1 + Y)\\sum_{i=1}\\dfrac{T_i}{1 - T_i}\\right). ] IgusaZetaFunction Input : arrangement : a hyperplane arrangement. Default None . matroid : a matroid. Default None . poset : a poset. Default None . verbose : turn on print statements. Default False . Output : the Igusa zeta function associated to the graded poset determined by the input data. For a compact discrete valuation ring $\\mathfrak{o}$ and a polynomial $f\\in \\mathfrak{o}[X_1,\\dots, X_d]$, Igusa's local zeta function associated with $f$ is [ Z_f(s) = \\int_{\\mathfrak{o}^d} |f(\\bm{X})|^s\\, |\\mathrm{d}\\bm{X}|. ] If $Q_\\mathcal{A}$ is the defining polynomial of a hyperplane arrangement, then Igusa's local zeta function associated $\\mathcal{A}$ is $Z_{Q_\\mathcal{A}}(s)$. The output to IgusaZetaFunction is a bivariate function in $y = q^{-1}$ and $t = q^{-s}$, where $q$ is the cardinality of the residue field of $\\mathfrak{o}$. This assumes good reduction ; see Section 1.1 of Maglione\u2013Voll. For data not represented by such a hyperplane arrangement, we define the Igusa zeta function associated with a graded poset $P$ to be [ Z_P(s) = \\mathsf{fHP}_P\\left(-q^{-1}, \\left(q^{-g_x(s)}\\right)_{x\\in P\\setminus \\{\\hat{0}\\}}\\right) , ] where $g_x(s) = \\mathrm{rank}(x) + \\#\\{a\\in P \\mid a\\leqslant x \\text{ and $a$ is an atom} \\} \\cdot s$. When $P$ is the intersection poset of a hyperplane arrangement $\\mathcal{A}$, then $Z_P(s)=Z_{Q_{\\mathcal{A}}}(s)$, which follows from Theorem B of Maglione\u2013Voll. Example (Uniform matroid) We compute the Igusa zeta function associated with the uniform matroid $U_{3,5}$. sage: M = matroids.Uniform(3, 5) sage: M U(3, 5): Matroid of rank 3 on 5 elements with circuit-closures {3: {{0, 1, 2, 3, 4}}} sage: hi.IgusaZetaFunction(matroid=M).factor() (y - 1) * (y*t - 1)^-2 * (y^4*t^2 - 4*y^3*t^2 + 3*y^3*t + 6*y^2*t^2 - 12*y^2*t + 6*y^2 + 3*y*t - 4*y + 1) * (y^3*t^5 - 1)^-1 Example (coordinate hyperplanes) We show that the Igusa zeta function of $f=x_1\\cdots x_{5}$ factors in the expected way. sage: A = hi.PolynomialToArrangement('*'.join(f'x{i}' for i in range(1, 6))) sage: A.hyperplanes() (Hyperplane 0*x1 + 0*x2 + 0*x3 + 0*x4 + x5 + 0, Hyperplane 0*x1 + 0*x2 + 0*x3 + x4 + 0*x5 + 0, Hyperplane 0*x1 + 0*x2 + x3 + 0*x4 + 0*x5 + 0, Hyperplane 0*x1 + x2 + 0*x3 + 0*x4 + 0*x5 + 0, Hyperplane x1 + 0*x2 + 0*x3 + 0*x4 + 0*x5 + 0) sage: hi.IgusaZetaFunction(A).factor() (y - 1)^5 * (y*t - 1)^-5 TopologicalZetaFuncion Input : arrangement : a hyperplane arrangement. Default None . matroid : a matroid. Default None . poset : a poset. Default None . verbose : turn on print statements. Default False . Output : the topological zeta function associated with the graded poset determined by the input data. For a graded poset $P$, the topological zeta function associated with $P$ is [ Z_{P}^{\\mathrm{top}}(s) = \\sum_{F\\in \\Delta(P\\setminus\\{\\hat{0}\\})} \\pi_{P,F}^\\circ(-1) \\prod_{x\\in F} \\dfrac{1}{g_x(s)} , ] where $g_x(s) = \\mathrm{rank}(x) + \\#\\{a\\in P \\mid a\\leqslant x \\text{ and $a$ is an atom} \\} \\cdot s$ and [ \\pi^{\\circ}_{P, F}(Y) = \\dfrac{\\pi_F(Y)}{(1 + Y)^{\\# F}}. ] When $P$ is the intersection poset associated with a hyperplane arrangement $\\mathcal{A}$, then $Z_{P}^{\\mathrm{top}}(s) = Z_{Q_{\\mathcal{A}}}^{\\mathrm{top}}(s)$, which follows from Corollaery 1.5 of Maglione\u2013Voll. Example (Shi arrangement) We consider the Shi $\\mathsf{A}_2$ arrangement and compute its topological zeta function. The Shi $\\mathsf{A}_2$ arrangement is defined to be [ \\mathcal{S} \\mathsf{A}_2 = \\left\\{X_i - X_j - k ~\\middle|~ 1\\leqslant i < j\\leqslant 3,\\; k\\in \\{0,1\\}\\right\\}. ] sage: A = hi.ShiArrangement(\"A2\") sage: A Arrangement of 6 hyperplanes of dimension 3 and rank 2 The topological zeta function is sage: Z = hi.TopologicalZetaFunction(A) sage: Z.factor() (s + 1)^-2 * (3*s + 2)^-1 * (12*s^3 + 2*s^2 - 5*s + 2) which is [ Z_{\\mathcal{S}\\mathsf{A}_2}^{\\mathrm{top}}(s) = \\dfrac{2 - 5s + 2s^2 + 12s^3}{(s+1)^2(3s+2)} . ]","title":"Rational Functions"},{"location":"rational_functions/#rational-functions","text":"The main purpose of this package is to explicitly compute the flag Hilbert\u2013Poincar\u00e9 series and its specializations like Igusa'a local zeta function. We defer to Maglione\u2013Voll for the details on the rational functions.","title":"Rational Functions"},{"location":"rational_functions/#braidarrangementigusa","text":"Input : a positive integer. Output : the Igusa zeta function associated with the braid arrangement. This is a specialized algorithm for the braid arrangement and is significantly faster than IgusaZetaFunction on the braid arrangement. This is based off of Lemma 5.14 of Maglione\u2013Voll.","title":"BraidArrangementIgusa"},{"location":"rational_functions/#example-time-comparison","text":"We compute the Igusa zeta function associated with $\\mathsf{A}_6$ and record the time (on the same machine). sage: %timeit _ = hi.BraidArrangementIgusa(6) 5.55 ms \u00b1 7.58 \u03bcs per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) sage: %timeit _ = hi.IgusaZetaFunction(hi.CoxeterArrangement(\"A6\")) 4.76 s \u00b1 28 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) Thus for $\\mathsf{A}_6$ BraidArrangementIgusa is about 1000 times faster than IgusaZetaFunction \u2014of course the latter is also general purpose.","title":"Example (Time comparison)"},{"location":"rational_functions/#example-large-example","text":"We compute a factorization of the denominator of the Igusa zeta function associated with $\\mathsf{A}_{10}$. sage: hi.BraidArrangementIgusa(10).denominator().factor() (y*t - 1)^5 * (y*t^2 - 1)^2 * (y*t^3 - 1) * (y*t^4 - 1) * (y^2*t^3 - 1)^3 * (y*t^5 - 1) * (y^2*t^4 + y*t^2 + 1)^2 * (y^2*t^5 - 1)^2 * (y^2*t^5 + 1)^2 * (y^2*t^7 - 1) * (y^2*t^9 - 1) * (y^2*t^9 + 1) * (y^2*t^10 + y*t^5 + 1) * (y^2*t^11 - 1) * (y^4*t^12 + y^3*t^9 + y^2*t^6 + y*t^3 + 1) * (y^4*t^14 + y^2*t^7 + 1) * (y^4*t^18 + 1) * (y^6*t^24 + y^5*t^20 + y^4*t^16 + y^3*t^12 + y^2*t^8 + y*t^4 + 1) * (y^6*t^30 + y^3*t^15 + 1) * (y^8*t^44 + y^6*t^33 + y^4*t^22 + y^2*t^11 + 1) Using a program to rewrite the finite geometric progressions in the denominator (like BRational ), the denominator takes the following form: (1 - y*t)^5*(1 - y^2*t^3)^3*(1 - y^3*t^6)^2*(1 - y^4*t^10)^2*(1 - y^5*t^15)*(1 - y^6*t^21)*(1 - y^7*t^28)*(1 - y^8*t^36)*(1 - y^9*t^45)*(1 - y^10*t^55)","title":"Example (Large example)"},{"location":"rational_functions/#coarsefhpseries","text":"Input : arrangement : a hyperplane arrangement. Default None . matroid : a matroid. Default None . poset : a poset. Default None . R_label : a function from pairs of elements of a poset into the integers. Default None . numerator : return only the numerator. Default False . verbose : turn on print statements. Default False . method : a string stating which method to use. Default recursion . Output : the coarse flag Hilbert\u2013Poincar\u00e9 series associated to the graded poset determined by the input. If R_label is given, it is not verified to be an $R$-label. To use the $R$-label, set method='R-label' . This will use the formula developed in Dorpalen-Barry et al. from Corollary 2.22. In testing, this method seems to be about two times slower than the default recursion. The coarse flag Hilbert\u2013Poincar\u00e9 series associated with a graded poset $P$ is defined to be: [ \\mathsf{cfHP}_{P} (Y, T) = \\sum_{F\\in\\Delta(P \\setminus \\{\\hat{0}\\})} \\pi_F(Y) \\left(\\dfrac{T}{1 - T}\\right)^{|F|} = \\dfrac{\\mathcal{N}_{P}(Y, T)}{(1 - T)^{\\mathrm{rk}(P)}}. ]","title":"CoarseFHPSeries"},{"location":"rational_functions/#example-boolean-arrangement","text":"We verify that the Boolean arrangement, $\\mathcal{A}$, of rank $n$ satisfies the equation [ \\mathsf{cfHP}_{\\mathcal{A}}(Y, T) = \\dfrac{(1+ Y)^n E_n(T)}{(1 - T)^n}, ] where $E_n(T)$ is the $n$th Eulerian polynomial. We set $n=6$ for this example. sage: A = hi.CoxeterArrangement([\"A1\"]*6) sage: A Arrangement of 6 hyperplanes of dimension 12 and rank 6 sage: cfHP = hi.CoarseFHPSeries(A) sage: cfHP.factor() (T - 1)^-6 * (T + 1) * (Y + 1)^6 * (T^4 + 56*T^3 + 246*T^2 + 56*T + 1)","title":"Example (Boolean arrangement)"},{"location":"rational_functions/#example-coxeter-at-footnotesize-y1","text":"We verify Theorem D of Maglione\u2013Voll for the Coxeter arrangement of type $\\mathsf{D}_5$. Thus, we will show that [ \\mathsf{cfHP}_{\\mathsf{D}_5} (1, T) = 1920\\cdot \\dfrac{1 + 26T + 66T^2 + 26T^3 + T^4}{(1 - T)^5}, ] sage: A = hi.CoxeterArrangement(\"D5\") sage: A Arrangement of 20 hyperplanes of dimension 5 and rank 5 sage: cfHP = hi.CoarseFHPSeries(A) sage: cfHP.factor() (-1) * (T - 1)^-5 * (Y + 1) * (Y^4*T^4 + 397*Y^4*T^3 + 19*Y^3*T^4 + 3143*Y^4*T^2 + 3074*Y^3*T^3 + 131*Y^2*T^4 + 3239*Y^4*T + 15624*Y^3*T^2 + 8556*Y^2*T^3 + 389*Y*T^4 + 420*Y^4 + 9694*Y^3*T + 25826*Y^2*T^2 + 9694*Y*T^3 + 420*T^4 + 389*Y^3 + 8556*Y^2*T + 15624*Y*T^2 + 3239*T^3 + 131*Y^2 + 3074*Y*T + 3143*T^2 + 19*Y + 397*T + 1) So we get exactly what we expect: sage: (cfHP(Y=1)).factor() (-1920) * (T - 1)^-5 * (T^4 + 26*T^3 + 66*T^2 + 26*T + 1)","title":"Example (Coxeter at ${\\footnotesize Y=1}$)"},{"location":"rational_functions/#example-the-path-poset","text":"We define the path poset $P_4 = \\{1,\\dots, 4\\}$ with the usual order $<$ of natural numbers. This is a graded poset with an $R$-label. We then compute the corresponding coarse flag Hilbert\u2013Poincar\u00e9 series. We note that there is no matroid whose lattice of flats is isomorphic to $P_n$. sage: P = Poset(DiGraph([(i, i+1) for i in range(1, 5)])) sage: hi.CoarseFHPSeries(poset=P).factor() (T - 1)^-4 * (Y + 1) * (Y*T + 1)^3","title":"Example (The path poset)"},{"location":"rational_functions/#flaghilbertpoincareseries","text":"Input : arrangement : a hyperplane arrangement. Default None . matroid : a matroid. Default None . poset : a poset. Default None . verbose : turn on print statements. Default False . Output : the flag Hilbert\u2013Poincar\u00e9 series associated to the graded poset determined by the input data. The flag Hilbert\u2013Poincar\u00e9 series of a graded poset $P$ is defined to be: [ \\mathsf{fHP}_{P} (Y, \\bm{T}) = \\sum_{F\\in\\Delta(P \\setminus \\{\\hat{0}\\})} \\pi_F(Y) \\prod_{x\\in F} \\frac{T_x}{1 - T_x}. ]","title":"FlagHilbertPoincareSeries"},{"location":"rational_functions/#example-lines-through-the-origin-again","text":"Because of the massive amount of variables in this function, we keep the number of hyperplanes small in this example. We compute the flag Hilbert\u2013Poincar\u00e9 series of the arrangement given by 5 lines passes through the origin in a $2$-dimensional vector space. sage: K = CyclotomicField(5) sage: R.<X, Y> = PolynomialRing(K) sage: f = X**5 - Y**5 sage: A = hi.PolynomialToArrangement(f) sage: A Arrangement of 5 hyperplanes of dimension 2 and rank 2 sage: hi.FlagHilbertPoincareSeries(A).factor() (T6 - 1)^-1 * (T5 - 1)^-1 * (T4 - 1)^-1 * (T3 - 1)^-1 * (T2 - 1)^-1 * (T1 - 1)^-1 * (Y + 1) * (Y*T1*T2*T3*T4*T5 + 4*T1*T2*T3*T4*T5 - Y*T1*T2*T3 - Y*T1*T2*T4 - Y*T1*T3*T4 - Y*T2*T3*T4 - 3*T1*T2*T3*T4 - Y*T1*T2*T5 - Y*T1*T3*T5 - Y*T2*T3*T5 - 3*T1*T2*T3*T5 - Y*T1*T4*T5 - Y*T2*T4*T5 - 3*T1*T2*T4*T5 - Y*T3*T4*T5 - 3*T1*T3*T4*T5 - 3*T2*T3*T4*T5 + 2*Y*T1*T2 + 2*Y*T1*T3 + 2*Y*T2*T3 + 2*T1*T2*T3 + 2*Y*T1*T4 + 2*Y*T2*T4 + 2*T1*T2*T4 + 2*Y*T3*T4 + 2*T1*T3*T4 + 2*T2*T3*T4 + 2*Y*T1*T5 + 2*Y*T2*T5 + 2*T1*T2*T5 + 2*Y*T3*T5 + 2*T1*T3*T5 + 2*T2*T3*T5 + 2*Y*T4*T5 + 2*T1*T4*T5 + 2*T2*T4*T5 + 2*T3*T4*T5 - 3*Y*T1 - 3*Y*T2 - T1*T2 - 3*Y*T3 - T1*T3 - T2*T3 - 3*Y*T4 - T1*T4 - T2*T4 - T3*T4 - 3*Y*T5 - T1*T5 - T2*T5 - T3*T5 - T4*T5 + 4*Y + 1) This is, indeed, equal to [ \\dfrac{1 + Y}{1 - T_6}\\left(1 + 4Y + (1 + Y)\\sum_{i=1}\\dfrac{T_i}{1 - T_i}\\right). ]","title":"Example (Lines through the origin again)"},{"location":"rational_functions/#igusazetafunction","text":"Input : arrangement : a hyperplane arrangement. Default None . matroid : a matroid. Default None . poset : a poset. Default None . verbose : turn on print statements. Default False . Output : the Igusa zeta function associated to the graded poset determined by the input data. For a compact discrete valuation ring $\\mathfrak{o}$ and a polynomial $f\\in \\mathfrak{o}[X_1,\\dots, X_d]$, Igusa's local zeta function associated with $f$ is [ Z_f(s) = \\int_{\\mathfrak{o}^d} |f(\\bm{X})|^s\\, |\\mathrm{d}\\bm{X}|. ] If $Q_\\mathcal{A}$ is the defining polynomial of a hyperplane arrangement, then Igusa's local zeta function associated $\\mathcal{A}$ is $Z_{Q_\\mathcal{A}}(s)$. The output to IgusaZetaFunction is a bivariate function in $y = q^{-1}$ and $t = q^{-s}$, where $q$ is the cardinality of the residue field of $\\mathfrak{o}$. This assumes good reduction ; see Section 1.1 of Maglione\u2013Voll. For data not represented by such a hyperplane arrangement, we define the Igusa zeta function associated with a graded poset $P$ to be [ Z_P(s) = \\mathsf{fHP}_P\\left(-q^{-1}, \\left(q^{-g_x(s)}\\right)_{x\\in P\\setminus \\{\\hat{0}\\}}\\right) , ] where $g_x(s) = \\mathrm{rank}(x) + \\#\\{a\\in P \\mid a\\leqslant x \\text{ and $a$ is an atom} \\} \\cdot s$. When $P$ is the intersection poset of a hyperplane arrangement $\\mathcal{A}$, then $Z_P(s)=Z_{Q_{\\mathcal{A}}}(s)$, which follows from Theorem B of Maglione\u2013Voll.","title":"IgusaZetaFunction"},{"location":"rational_functions/#example-uniform-matroid","text":"We compute the Igusa zeta function associated with the uniform matroid $U_{3,5}$. sage: M = matroids.Uniform(3, 5) sage: M U(3, 5): Matroid of rank 3 on 5 elements with circuit-closures {3: {{0, 1, 2, 3, 4}}} sage: hi.IgusaZetaFunction(matroid=M).factor() (y - 1) * (y*t - 1)^-2 * (y^4*t^2 - 4*y^3*t^2 + 3*y^3*t + 6*y^2*t^2 - 12*y^2*t + 6*y^2 + 3*y*t - 4*y + 1) * (y^3*t^5 - 1)^-1","title":"Example (Uniform matroid)"},{"location":"rational_functions/#example-coordinate-hyperplanes","text":"We show that the Igusa zeta function of $f=x_1\\cdots x_{5}$ factors in the expected way. sage: A = hi.PolynomialToArrangement('*'.join(f'x{i}' for i in range(1, 6))) sage: A.hyperplanes() (Hyperplane 0*x1 + 0*x2 + 0*x3 + 0*x4 + x5 + 0, Hyperplane 0*x1 + 0*x2 + 0*x3 + x4 + 0*x5 + 0, Hyperplane 0*x1 + 0*x2 + x3 + 0*x4 + 0*x5 + 0, Hyperplane 0*x1 + x2 + 0*x3 + 0*x4 + 0*x5 + 0, Hyperplane x1 + 0*x2 + 0*x3 + 0*x4 + 0*x5 + 0) sage: hi.IgusaZetaFunction(A).factor() (y - 1)^5 * (y*t - 1)^-5","title":"Example (coordinate hyperplanes)"},{"location":"rational_functions/#topologicalzetafuncion","text":"Input : arrangement : a hyperplane arrangement. Default None . matroid : a matroid. Default None . poset : a poset. Default None . verbose : turn on print statements. Default False . Output : the topological zeta function associated with the graded poset determined by the input data. For a graded poset $P$, the topological zeta function associated with $P$ is [ Z_{P}^{\\mathrm{top}}(s) = \\sum_{F\\in \\Delta(P\\setminus\\{\\hat{0}\\})} \\pi_{P,F}^\\circ(-1) \\prod_{x\\in F} \\dfrac{1}{g_x(s)} , ] where $g_x(s) = \\mathrm{rank}(x) + \\#\\{a\\in P \\mid a\\leqslant x \\text{ and $a$ is an atom} \\} \\cdot s$ and [ \\pi^{\\circ}_{P, F}(Y) = \\dfrac{\\pi_F(Y)}{(1 + Y)^{\\# F}}. ] When $P$ is the intersection poset associated with a hyperplane arrangement $\\mathcal{A}$, then $Z_{P}^{\\mathrm{top}}(s) = Z_{Q_{\\mathcal{A}}}^{\\mathrm{top}}(s)$, which follows from Corollaery 1.5 of Maglione\u2013Voll.","title":"TopologicalZetaFuncion"},{"location":"rational_functions/#example-shi-arrangement","text":"We consider the Shi $\\mathsf{A}_2$ arrangement and compute its topological zeta function. The Shi $\\mathsf{A}_2$ arrangement is defined to be [ \\mathcal{S} \\mathsf{A}_2 = \\left\\{X_i - X_j - k ~\\middle|~ 1\\leqslant i < j\\leqslant 3,\\; k\\in \\{0,1\\}\\right\\}. ] sage: A = hi.ShiArrangement(\"A2\") sage: A Arrangement of 6 hyperplanes of dimension 3 and rank 2 The topological zeta function is sage: Z = hi.TopologicalZetaFunction(A) sage: Z.factor() (s + 1)^-2 * (3*s + 2)^-1 * (12*s^3 + 2*s^2 - 5*s + 2) which is [ Z_{\\mathcal{S}\\mathsf{A}_2}^{\\mathrm{top}}(s) = \\dfrac{2 - 5s + 2s^2 + 12s^3}{(s+1)^2(3s+2)} . ]","title":"Example (Shi arrangement)"}]}